---
sidebar_position: 41
title: DataHandlerContext interface
description: Processor Context API 
---

# Processor Context

`DataHandlerContext` is a generic interface defined as follows: 
```ts
export interface DataHandlerContext<Store, F extends FieldSelection> {
    /**
     * access to the chain and the metadata
     * @internal
     */
    _chain: Chain
    log: Logger
    /**
     * Handle for the data sink
     */
    store: Store
    /**
     * A batch of data items to be processed, grouped into blocks
     */
    blocks: BlockData<F>[]
    /**
     * Signals that the processor has reached the chain head.
     * The head block is always included in `.blocks`.
     */
    isHead: boolean
}
```

The `F` type is the type of the argument of the `.setFields()` processor configuration method argument. `Store` type is inferred from the `Database` instance passed into the `run()` method.
:::info
At the moment `DataHandlerContext` interface is only used by the EVM processor; Substrate processor relies on its older [`BatchContext` equivalent](/firesquid/basics/processor-context). This will change upon the ArrowSquid for Substrate release.
:::

[//]: # (!!!! Remove the notice once ArrowSquid for Substrate is released)

## `ctx._chain`

Internal handle for direct access to the underlying chain state via RPC calls. Rarely used directly, but rather by the facade access classes generated by the [typegen tools](/glossary/#typegen).

## `ctx.store`

Interface for the target data sink. See [Persisting data](/basics/store).

## `ctx.log` 

The native logger handle. See [Logging](/basics/logging).

## `ctx.blocks`

The on-chain data items are grouped into blocks, with each block containing a header and an iterable for every supported data item type (event log, transaction, trace etc). Depending on the data item type, the items in the iterables can be canonically ordered by how the data is recorded on-chain. The shape of item objects is determined by the processor configuration done via the `.setFields()` method.

An idiomatic use of the context API is to iterate first over blocks and then over each iterable of each block:

```ts
processor.run(new TypeormDatabase(), async (ctx) => {
  for (let block of ctx.blocks) {
    for (let log of block.logs) {
      // filter and process logs
    }
    for (let txn of block.transactions) {
      // filter and process transactions
    }
    // iterate over, filter and process any other data items
  }
})
```
Note that the processor does not guarantee that no data not matching its filters will get into iterables, only that the data matching the filters will. Hence, the data must be filtered in the batch handler before processing.

The canonical ordering of `ctx.blocks` enables efficient in-memory data processing. For example, multiple updates of the same entity can be compressed into a single database transaction.

## `ctx.isHead`

Is `true` if the processor has reached the chain head. The last block `ctx.blocks` is then the current chain tip.
