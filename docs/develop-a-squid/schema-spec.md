---
sidebar_position: 2
description: >-
  The schema file defines the target data model with a GraphQL dialect.
---

# The schema file

The file `schema.graphql` defines the target database schema and the corresponding TypeORM entity classes generated by [`squid-substrate-typegen(1)`](https://github.com/subsquid/squid/tree/master/substrate-typegen). The schema is defined with a GraphQL dialect enriched with special directives.  

The schema file also defines the GraphQL API of the [OpenReader](https://github.com/subsquid/squid/tree/master/openreader) server to present the data. This page only describes the database schema part.

## Entities

Entities are defined by root-level GraphQL types decorated with `@entity`. The entity names and the properties are expected to be camelCased and are converted into snake_cased database tables and columns. The primary key column is always mapped to the entity field of a special `ID` type. Non-nullable fields are marked with an exclamation mark (`!`) and are nullable otherwise. 

The following [scalar types](https://graphql.org/learn/schema/#scalar-types) are supported by the `schema.graphql` dialect:

- `Boolean` (mapped to `bool`)
- `BigInt` (mapped to `numeric`)
- `DateTime` (mapped to `timestamptz`)
- `Bytes` (mapped to `bytea`)
- `JSON` (mapped to `jsonb`)
- `String` (mapped to `text`)
- `Int` (mapped to `int4`)
- Enums (mapped to `text`)
- User-defined scalars (non-entity types). Such properties are mapped as `jsonb` columns.

**Example** 
```graphql
type Scalar @entity {
    id: ID!
    boolean: Boolean
    string: String
    enum: Enum
    bigint: BigInt
    dateTime: DateTime
    bytes: Bytes
    json: JSON,
    deep: DeepScalar
}
        
type DeepScalar {
    bigint: BigInt
    dateTime: DateTime
    bytes: Bytes
    boolean: Boolean
}
        
enum Enum {
    A B C
}
```

## Arrays

Entity fields can be an array of any scalar type and are mapped to the corresponding Postgres array types. The array elements may be defined as nullable or non-nullable.

**Example**

```graphql
type Lists @entity {
    intArray: [Int!]!
    enumArray: [Enum!]
    bigintArray: [BigInt!]
    datetimeArray: [DateTime!]
    bytesArray: [Bytes!]
    listOfListOfInt: [[Int]]
    listOfJsonObjects: [Foo!]
}
        
enum Enum {
    A B C D E F
}
        
type Foo {
    foo: Int
    bar: Int
}
```

## Entity relations

## Indexes

To add an index to a column, the corresponding entity field must be decorated with `@index`. It is crucial to index the entity fields for which one expects filtering and ordering at the API level.

Multi-column indices can be defined on the entity level, with the additional `unique` option. 

```grapqhl
type Foo @entity @index(fields: ["baz", "bar"], unique: true) {
    id: ID!
    bar: Int!
    baz: [Enum!]
  }
```
 
## Typed JSON

## Union types
